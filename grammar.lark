start: (_NEWLINE | stmt)*

suite: simple_stmt | _NEWLINE _INDENT stmt+ _DEDENT

?stmt: simple_stmt | compound_stmt
?simple_stmt: small_stmt _NEWLINE
?small_stmt: return_stmt | assign_stmt | expr_stmt
?compound_stmt: func_def | conditional_stmt | while_stmt | for_stmt

func_def: ":" type_hint "->" "(" [params] ")" NAME "fed" suite

params: param ("," param)*
param: type_hint ":" NAME

return_stmt: "nruter" [expr] 
assign_stmt: NAME ":" type_hint "=" expr
expr_stmt: expr

conditional_stmt: if_stmt (elif_stmt)* [else_stmt]
if_stmt: ":" expr "fi" suite
elif_stmt: ":" expr "file" suite
else_stmt: ":" "esle" suite

while_stmt: ":" expr "elihw" suite
for_stmt: ":" loop_expr "ni" NAME "rof" suite


loop_expr: STRING | range_expr
range_expr: "range" "(" (NUMBER | func_call) ")"

?expr: logic_or
?logic_or: logic_and (OR logic_and)*
?logic_and: logic_not (AND logic_not)*
?logic_not: NOT logic_not -> not_expr
          | comparison

?comparison: sum (comp_op sum)*
!comp_op: EQ | NE | LT | GT | LE | GE

?sum: product (add_op product)*
!add_op: PLUS | MINUS

?product: atom (mul_op atom)*
!mul_op: TIMES | DIV | MOD

?atom: NUMBER        -> number
     | STRING        -> string
     | TRUE          -> true
     | FALSE         -> false
     | NONE          -> none
     | NAME          -> var
     | func_call
     | "(" expr ")"

func_call: NAME "(" [arguments] ")"
arguments: expr ("," expr)*

type_hint: "tni" -> type_int
        | "rts" -> type_str
        | "loob" -> type_bool
        | "enoN" -> type_none
        | "taolf" -> type_float

DEF:    "fed"
RETURN: "nruter"
WHILE:  "elihw"
FOR:    "rof"
IN:     "ni"
TRUE:   "eurT"
FALSE:  "eslaF"
NONE:   "enoN"
AND:    "dna"
OR:     "ro"
NOT:    "ton"

PLUS:   "+"
MINUS:  "-"
TIMES:  "*"
DIV:    "/"
MOD:    "%"
ASSIGN: "="
EQ:     "=="
NE:     "!="
LT:     "<"
GT:     ">"
LE:     "<="
GE:     ">="

NAME: /[a-zA-Z_]\w*/
NUMBER: /\d+(\.\d+)?/
STRING: /".*?"/

COMMENT: /#[^\n]*/
%ignore COMMENT
%ignore /[ \t\f]+/
%ignore /\\[\t \f]*\r?\n/

_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+

%declare _INDENT _DEDENT