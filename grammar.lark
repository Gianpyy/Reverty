start: (_NEWLINE | stmt)*

suite: simple_stmt | _NEWLINE _INDENT stmt+ _DEDENT

?stmt: simple_stmt | compound_stmt
?simple_stmt: small_stmt _NEWLINE
?small_stmt: return_stmt | assign_stmt | expr_stmt
?compound_stmt: func_def | conditional_stmt | while_stmt | for_stmt

func_def: ":" type_hint "->" "(" [params] ")" NAME "fed" suite

params: param ("," param)*
param: type_hint ":" NAME

return_stmt: "nruter" [expr] 
assign_stmt: NAME (":" type_hint)? "=" expr
expr_stmt: expr

conditional_stmt: if_stmt (elif_stmt)* [else_stmt]
if_stmt: ":" expr "fi" suite
elif_stmt: ":" expr "file" suite
else_stmt: ":" "esle" suite

while_stmt: ":" expr "elihw" suite
for_stmt: ":" loop_expr "ni" NAME "rof" suite


loop_expr: STRING | range_expr
range_expr: "range" "(" (NUMBER | func_call) ")"

?expr: logic_or
?logic_or: logic_and ("ro" logic_and)*
?logic_and: logic_not ("dna" logic_not)*
?logic_not: "ton" logic_not -> not_expr
          | comparison
          | add_op atom

?comparison: sum (comp_op sum)*
!comp_op: "==" | "!=" | "<" | ">" | "<=" | ">="

?sum: product (add_op product)*
!add_op: "+" | "-"

?product: atom (mul_op atom)*
!mul_op: "*" | "/" | "%"

?atom: NUMBER        -> number
     | STRING        -> string
     | "eurT"          -> true
     | "eslaF"         -> false
     | "enoN"          -> none
     | NAME          -> var
     | func_call
     | "(" expr ")"

func_call: NAME "(" [arguments] ")"
arguments: expr ("," expr)*

type_hint: "tni" -> type_int
        | "rts" -> type_str
        | "loob" -> type_bool
        | "enoN" -> type_none
        | "taolf" -> type_float

NAME: /[a-zA-Z_]\w*/
NUMBER: /\d+(\.\d+)?/
STRING: /".*?"/

COMMENT: /#[^\n]*/
%ignore COMMENT
%ignore /[ \t\f]+/
%ignore /\\[\t \f]*\r?\n/

_NEWLINE: ( /\r?\n[\t ]*/ | COMMENT )+

%declare _INDENT _DEDENT